<template>
  <div
    ref="IZ-select"
    :tabindex="disableSearch ? 0 : -1"
    :class="{
      'IZ-select': true,
      'IZ-select--with-value': inputValue,
      // —Å—Ç–∞–≤–∏—Ç –∫–ª–∞—Å—Å —Ä–∞–∑–º–µ—Ä–∞ –µ—Å–ª–∏ prop size –Ω–µ –¥–µ—Ñ–æ–ª—Ç–Ω–æ–µ
      ...(size === SIZES.DEFAULT
        ? null
        : ({ ['IZ-select--' + size]: true })
      )
    }"
    @keydown.up="onSelectByArrow"
    @keydown.down="onSelectByArrow"
    @keydown.enter="onEnter"
    @keydown.tab.esc="setBlured"
    @mousedown="onClick"
    @focus="setFocused"
  >
    <div class="IZ-select__input-wrap">
      <slot
        name="input-before"
      />

      <div
        ref="IZ-select__input"
        :class="{
          'IZ-select__input': true,
          'IZ-select__input--focused': focused,
          'IZ-select__input--has-menu': hasMenu,
          'IZ-select__input--has-error': hasError,
          'IZ-select__input--successful': successful,
          'IZ-select__input--selection-slot': showSelectionSlot,
          'IZ-select__input--disabled': disabled,
          'IZ-select__input--readonly': readonly
        }"
        :style="inputStyles"
      >
        <slot
          :loading="loading"
          name="input-start"
        />

        <slot
          v-if="showSelectionSlot"
          :item="selectedItem"
          name="selection"
        />

        <input
          v-if="simpleInput"
          ref="IZ-select__input-for-text"
          v-bind="{
            value,
            placeholder,
            class: inputForTextClass,
            disabled,
            readonly,
            tabindex: 0,
            type: 'text',
            autocomplete: 'new-password',
            ...inputElCustomAttributes,
            style: inputForTextStyles,
          }"
          @keyup="onSearchKeyUp"
          @keydown="onSearchKeyDown"
          @input="$emit('input', $event.target.value)"
          @mousedown="onClick"
          @focus="setFocused(true)"
        >
        <input
          v-else
          ref="IZ-select__input-for-text"
          v-bind="{
            value: inputValue,
            placeholder,
            class: inputForTextClass,
            disabled: disableSearch || disabled,
            readonly,
            tabindex: disableSearch ? -1 : 0,
            type: 'text',
            role: 'combobox',
            autocomplete: 'new-password',
            ...inputElCustomAttributes,
            style: inputForTextStyles,
          }"
          @keyup="onSearchKeyUp"
          @keydown="onSearchKeyDown"
          @input="onSearch"
          @mousedown="onClick"
          @focus="setFocused(true)"
        >

        <slot
          :loading="loading"
          name="input-end"
        />
      </div>

      <slot
        name="input-after"
      />
    </div>

    <template v-if="!simpleInput">
      <div
        v-for="menuPos of [MENU_POSITIONS.TOP, MENU_POSITIONS.BOTTOM]"
        :key="'menu-position-' + menuPos"
        :ref="'IZ-select__menu-' + menuPos"
        :style="{
          'pointer-events': hasMenu ? 'auto' : 'none',
          ...getMenuDynamicStyles(menuPos)
        }"
        :class="{
          [`IZ-select__menu IZ-select__menu--at-${menuPos}`]: true,
          'IZ-select__menu--disable-search': disableSearch
        }"
      >
        <slot name="before-items-fixed" />

        <div
          ref="IZ-select__menu-items"
          :style="{
            'max-height': menuItemsMaxHeight
          }"
          class="IZ-select__menu-items"
          @scroll="onScroll"
        >
          <slot name="before-items">
            <div style="height: 8px;" />
          </slot>

          <!--itemsComputedWithScrollLimit-->
          <div
            v-for="(item, i) in itemsComputed"
            v-show="i < scrollItemsLimitCurrent || (arrowsIndex && i <= arrowsIndex)"
            ref="items"
            :key="'IZ-item-' + i"
            :class="{
              'IZ-select__item': true,
              'IZ-select__item--selected': isItemSelected(item)
            }"
            @click="onClickSelectItem(item)"
          >
            <slot
              :item="item"
              name="item"
            >
              <span>
                {{ getItemText(item) }}
              </span>
            </slot>
          </div>

          <div
            v-if="!itemsComputed.length && !loading"
            class="IZ-select__no-data"
          >
            <slot name="no-data">
              {{ $coolSelect.options.text.noData }}
            </slot>
          </div>

          <slot name="after-items">
            <div style="height: 8px;" />
          </slot>
        </div>

        <slot name="after-items-fixed" />

        <div style="position: absolute; top: 0; left: 0; right: 0;">
          <slot name="before-items-fixed-absolute" />
        </div>
        <div style="position: absolute; bottom: 0; left: 0; right: 0;">
          <slot name="after-items-fixed-absolute" />
        </div>
      </div>
    </template>

    <transition name="fade">
      <div
        v-show="errorMessage"
        class="IZ-select__error"
      >
        <slot
          :errorMessage="errorMessage"
          name="error"
        >
          {{ errorMessage }}
        </slot>
      </div>
    </transition>
  </div>
</template>

<script>
import { isObject, getOffsetSum } from './helpers'
import eventsListeners from './eventsListeners'
import props from './props'
import computed from './computed'
import { SIZES, MENU_POSITIONS } from '~/constants'
import { outOfViewportGetFreePosition } from '~/helpers'

export default {
  name: 'VueSelect',
  // introduction: 'an amazing select',
  description: `
  This \`select\` is amazing, you should _check_ it out üòä.
  `,
  token: `<cool-select v-model="selected" :items="items" />`,
  props,
  data () {
    return {
      MENU_POSITIONS,
      SIZES,
      wishShowMenu: false,
      arrowsIndex: null,
      focused: false,
      selectedItem: null,
      selectedItemByArrows: null,
      // readonly
      searchData: '',
      scrollItemsLimitCurrent: this.scrollItemsLimit,
      // addEventListener identifier
      listeners: {
        mousedown: ({ target }) => {
          const select = this.$refs['IZ-select']

          if (this.focused && select && !select.contains(target)) {
            this.setBlured()
          }
        },
        scroll: this.menuCalculatePos,
        resize: this.menuCalculatePos
      },
      menuCurrentPosition: this.menuDefaultPosition,
      lastMenuDynamicStyles: null,
      // —á—Ç–æ–±—ã –Ω–µ –≤—ã–∑—ã–≤–∞–ª—Å—è input –∏–∑-–∑–∞ selectedItem (–≤ created –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è setSelectedItemByValue)
      ignoreFirstInputEvent: true
    }
  },
  computed,
  watch: {
    searchText (val) {
      this.setSearchData(val)
    },
    value () {
      this.setSelectedItemByValue()
    },
    items () {
      this.setSelectedItemByValue()
    },
    selectedItem () {
      if (this.ignoreFirstInputEvent) {
        this.ignoreFirstInputEvent = false

        return
      }

      this.selectedItemByArrows = null

      this.$emit('input', this.currentItemValue)
    },
    itemsComputed (items) {
      this.$emit('change-displayed-items', items)
    }
  },
  created () {
    if (this.eventEmitter) {
      this.eventEmitter.on('set-search', this.setSearchData)
    }

    // TODO –≤–æ–∑–º–æ–∂–Ω–æ —Å—Ç–æ–∏—Ç —É–±—Ä–∞—Ç—å —á—Ç–æ–±—ã –Ω–µ –≤—ã–∑—ã–≤–∞–ª—Å—è –ª–∏—à–Ω–∏–π setSelectedItemByValue
    this.setSelectedItemByValue()
  },
  mounted () {
    // listener for window (see removeEventListener on beforeDestroy hook)
    window.addEventListener('mousedown', this.listeners.mousedown)

    if (this.menuDynamicPosition) {
      window.addEventListener('scroll', this.listeners.scroll)
      window.addEventListener('resize', this.listeners.resize)
    }
  },
  beforeDestroy () {
    window.removeEventListener('mousedown', this.listeners.mousedown)

    if (this.menuDynamicPosition) {
      window.removeEventListener('scroll', this.listeners.scroll)
      window.removeEventListener('resize', this.listeners.resize)
    }
  },
  methods: {
    ...eventsListeners,
    getMenuDynamicStyles (menuPos) {
      const isCurrentMenu = this.menuCurrentPosition === menuPos && this.hasMenu
      const obj = {
        visibility: isCurrentMenu ? 'visible' : 'hidden',
        opacity: +isCurrentMenu
      }

      // –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —Å—Ç–∞—Ä—É—é –ø–æ–∑–∏—Ü–∏—é –µ—Å–ª–∏ –Ω–µ—Ç –º–µ–Ω—é, —á—Ç–æ–±—ã —Å—Ç–∏–ª–∏ –Ω–µ –¥—ë—Ä–≥–∞–ª–∏—Å—å
      if (!this.hasMenu) return { ...this.lastMenuDynamicStyles, ...obj }

      const input = this.$refs['IZ-select__input']
      // —à–∏—Ä–∏–Ω–∞ –∏ —Å–º–µ—â–µ–Ω–∏–µ —Å–ª–µ–≤–∞ —Ç–∞–∫–∏–µ –∂–µ –∫–∞–∫ –∏ —É –ø–æ–ª—è –≤–≤–æ–¥–∞
      obj.width = input.offsetWidth + 'px'
      obj.left = input.offsetLeft + 'px'

      if (menuPos === MENU_POSITIONS.BOTTOM) {
        obj.top = input.offsetTop + input.offsetHeight + 'px'

        if (this.disableSearch) {
          obj.top = input.offsetTop + 'px'
        }
      } else if (menuPos === MENU_POSITIONS.TOP) {
        obj.bottom = '100%'

        if (this.disableSearch) {
          obj.bottom = 0
        }
      }

      this.lastMenuDynamicStyles = obj

      return obj
    },
    // –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ—Ç –º–µ–Ω—é —á—Ç–æ–±—ã –Ω–µ –≤—ã—Ö–æ–¥–∏–ª–æ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—É viewport
    menuCalculatePos () {
      if (!this.menuDynamicPosition) return

      if (this.hasMenu) {
        const newPosTop = outOfViewportGetFreePosition(this.$refs['IZ-select__menu-' + MENU_POSITIONS.TOP][0])
        const newPosBottom = outOfViewportGetFreePosition(this.$refs['IZ-select__menu-' + MENU_POSITIONS.BOTTOM][0])

        if (!newPosTop && !newPosBottom) {
          this.menuCurrentPosition = this.menuDefaultPosition
        } else {
          this.menuCurrentPosition = newPosTop || newPosBottom
        }
      }
    },
    getSearchData () {
      return this.searchData
    },
    setSearchData (val) {
      this.searchData = val

      this.$emit('update:search-text', val)
    },
    setInputFocused () {
      this.$refs['IZ-select__input-for-text'].focus()
    },
    setInputSelected () {
      setTimeout(() => {
        // –í—Ä–æ–¥–µ –Ω–µ –Ω—É–∂–Ω–æ https://stackoverflow.com/a/5001669/5286034
        // if (isTextSelected(this.$refs['IZ-select__input-for-text'])) return

        this.$refs['IZ-select__input-for-text'].select()
      }, 100)
    },
    setFocused (byInput = false) {
      if (this.focused || this.disabled || this.readonly) return

      // if search enabled
      if (!this.disableSearch && !byInput) {
        // focus text input
        this.setInputFocused()
      }

      if (window.scrollTo && this.allowMobileScroll && this.isMobile) {
        const { top } = getOffsetSum(this.$refs['IZ-select__input'])

        // scroll to component input el
        window.scrollTo({
          // this.$refs['IZ-select__input'].offsetTop - 8
          // (bug with position: relative; https://github.com/iliyaZelenko/vue-cool-select/issues/10)
          top: top - 8,
          behavior: 'smooth'
        })
      }

      if (this.selectTextOnFocus) this.setInputSelected()

      this.focused = true

      this.showMenu()
      this.$emit('focus')
    },
    // TODO –ø—Ä–∞–≤–∏–ª—å–Ω–µ–µ blurred!
    setBlured () {
      if (this.resetSearchOnBlur) {
        this.setSearchData('')
      }
      this.focused = false

      this.hideMenu()
      this.$refs['IZ-select__input-for-text'].blur()
      this.$emit('blur')
    },
    // TODO –≤—ã–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –≤ watch, –≤ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö —É–±—Ä–∞—Ç—å, —Ç–∞–º –ø—Ä–æ–≤–µ—Ä—è—Ç—å –µ—Å–ª–∏ !== null, —Ç–æ –≤—ã–∑—ã–≤–∞—Ç—å
    fireSelectEvent (item) {
      this.selectedItemByArrows = null

      this.$nextTick(() => {
        this.$emit('select', item)
      })
    },
    getItemText (item) {
      if (!item) return null
      if (this.itemText) return item[this.itemText]

      if (isObject(item)) {
        const keys = Object.keys(item)

        if (keys.length === 1) {
          return item[keys[0]]
        }

        return item
      }

      return item
    },
    getItemValue (item) {
      // if null or undefined
      if (item == null) return null
      if (this.itemValue) return item[this.itemValue]

      if (isObject(item)) {
        const keys = Object.keys(item)

        if (keys.length === 1) {
          return item[keys[0]]
        }

        return item
      }

      return item
    },
    // —Å—Ç–∞–≤–∏—Ç –≤—ã–±—Ä–∞–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é
    setSelectedItemByValue () {
      if (!this.items.length) {
        this.selectedItem = null

        return
      }

      this.selectedItem = this.itemsComputed.find(i => {
        // TODO –≤—ã–Ω–µ—Å—Ç–∏ –ø–æ–ª—É—á–µ–Ω–∏–µ this.value –≤ computed (–æ–Ω–æ —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–º –º–µ—Ç–æ–¥–µ –ø–æ–∫–∞)
        // —Å–¥–µ–ª–∞—Ç—å —Ç—É—Ç —Ç–∞–∫—É—é –ø—Ä–≤–æ–µ—Ä–∫—É return this.getItemValue(i) === this.computedValue()

        // –µ—Å–ª–∏ "{}" (–Ω–µ –º–∞—Å—Å–∏–≤, –Ω–µ —Ñ—É–Ω–∫—Ü–∏—è, –Ω–µ null...)
        if (isObject(this.value)) {
          // –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –æ–±—ä–µ–∫—Ç–∞ this.value
          const valFromObjVal = this.getItemValue(this.value)

          return this.getItemValue(i) === valFromObjVal
        }

        return this.getItemValue(i) === this.value
      })
    },
    // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ –∏—Ç–µ–º—ã
    filteredBySearchItems (items) {
      if (!this.getSearchData() || this.disableFilteringBySearch) return items

      return items.filter(i =>
        this.filter(i, this.getSearchData(), this.getItemText(i))
      )
    },
    isItemSelected (item) {
      return item === this.selectedItemByArrows || (item === this.selectedItem && !this.selectedItemByArrows)
    },
    showMenu () {
      if (this.hasMenu) return

      this.wishShowMenu = true

      this.menuCalculatePos()
    },
    hideMenu () {
      if (!this.hasMenu) return

      this.wishShowMenu = false
    }
  }
}
</script>

<!--–°—Ç–∏–ª–∏ –Ω–µ –ø–∏—Å–∞—Ç—å –≤ —Ç–µ–≥ <style>, –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –≤ .styl —Ñ–∞–π–ª—ã, –≤—Å–µ—Ä–∞–≤–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è BEM.-->
